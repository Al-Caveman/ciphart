<p align="center">
    <img src="pics/logo.png">
</p>

# intro

`ciphart` can do:

- **encrypt/decrypt:** only encrypt/decrypt a file using xchacha20 (i.e. `-e` and `-d` actions).
- **derive better keys:** only derive a more secure key using a novel key derivation function (i.e.
  `-k` action).
- **both:** do both (i.e. `-ek` and `-dk` actions).

but, you may ask, why yet another tool?  isn't the tool
[`scrypt`](https://www.tarsnap.com/scrypt.html) enough?  answer is _no_,
here is why:

- **guaranteed entropy:** the novel key derivation function is the only one
  out there that objectively quantifies the amount of increased security
  against brute-forcing attacks in the unit of entropy bits.  this is also
  guaranteed independent of attacker's hardware.
- **modern crypto algorithm:** xchacha20 is a new algorithm, and not much
  tools out there.  hence the need to create a new tool.
- **made for humans:** neat command-line interface that allows to accept
  both, the password and the input file via STDIN; something not possible
  with some tools such as [`scrypt`](https://www.tarsnap.com/scrypt.html).

# installation

1.  install [`libsodium`](https://libsodium.gitbook.io/doc/).
2. run `make`.  optionally run `make test`.
3. somehow put `ciphart` executable somewhere in `PATH` (personally i
   symbolically linked it to `/usr/bin/ciphart`).

# how entropy is calculated?  why is it guaranteed?

[the _idea_ is explained
here](https://crypto.stackexchange.com/questions/85676/how-to-estimate-the-maximum-computational-cost-bound-for-key-derivation-function).
for more info, you may read the code (it's small), or ask me by submitting
an issue.

note that this entropy calculation is not a mere heuristic.  this is
guaranteed to be true regarless of attacker's hardware/software
implementation of xchacha20.  i.e. regardless of how fast attacker's
xchacha20 implementation is, the effect of the KDF is maintained.  e.g. if
the KDF claims to inject `20` bits of entropy, it is held as follows:  the
attacker's password bruteforcing will increase exactly as if your password
had `20` extra entropy bits.

#### what does that even mean?

here is an example: 

1. starting from [Kerckhoffs's
   principle](https://en.wikipedia.org/wiki/Kerckhoffs%27s_principle),
   suppose that the adversary knows that you generate your passwords using,
   say, `pwqgen random=50`.  so the attacker knows that your password has
   50 bits of entropy (but doesn't know the actual password).  your
   password perhaps may look something like `acre&mature$Known8`, which is
   memorable.  

2. then you used it to encrypt some file by using the command `ciphart -ekn
   20 -i secret.txt -o secret.enc`.  also suppose that the attacker knows
   that you invoked this `ciphart` command.

3. then, suppose that the attacker got your encrypted file.  the question
   is, how many passwords does he need to brute-force in order to guarantee
   finding your password?  the answer is, obviously `2^50`.  but, thanks to
   `ciphart`, it will be as hard as brute-forcing a better key with `2^70`
   entropy bits!

in other words, you memorise an easy password with `50` entropy bits, which
takes about 30 years to brute-force on my computer, such as
`acre&mature$Known8` (generated by `pwqgen random=50`), except that
`ciphart` effectively makes you get the increased security as if you had a
`70` entropy bit password like this `harder-bigger&sit3inch3other`
(generated by `pwqgen random=70`), which takes _over 3000 CENTURIES_ to
brute-force on my computer!

isn't it nice that `ciphart`'s key derivation function has this ability to
let you interpret its contribution to your security in the unit of entropy?
so that you actually know how much security you have gained?  other key
derivation functions don't have this feature!


# how to utter `ciphart`?

two options:

- `sai fart` (preferred).
- `sip heart`.
